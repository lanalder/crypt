<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <style>
    body {
      background-color: #fff8f6;
    }
    textarea:focus {
  	  outline: 0;
    }
    .big-contain {
      display: flex;
      flex-direction: row;
      align-items: indie-between;
    }
    .c-container,
    .dc-container {
      display: flex;
      margin-top: 10vh;
      flex-direction: column;
      justify-content: center;
      flex-grow: 1;
    }
    .ctext,
    .dctext {
      appearance: none;
      height: 25vh;
      box-shadow: inset 0px 1px 0px 0px #8e8e8e;
      background-color: #f7f2f0;
      margin: 2vh 2vw 2vh 2vw;
    }
    .cipherB,
    .dcipherB {
      box-shadow: 0px 1px 1px 0px #8e8e8e;
      background-color: #f7f2f0;
      margin-top: 2vh;
      align-self: center;
      width: 20%;
      font-size: 0.8rem;
      text-align: center;
      cursor: pointer;
    }
  </style>
  <title>Document</title>
</head>
<body>
  <div class="big-contain">
    <div class="c-container">
      <textarea type="compact" class="ctext" required minlength="5" maxlength="8000"></textarea>
      <div class="cipherB">get cipherd</div>
    </div>
    <div class="dc-container">
      <textarea type="compact" class="dctext" required minlength="5" maxlength="8000"></textarea>
      <div class="dcipherB">de-nonsensify</div>
    </div>
  </div>
</body>
<script>

  const abc = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q', 'r','s','t','u','v','w','x','y','z'],
      freqTab = [8.15,1.44,2.76,3.79,13.11,2.92,1.99,5.26,6.35,0.13,0.42,3.39,2.54, 7.10,8.00,1.98,0.12,6.83,6.10,10.47,2.46,0.92,1.54,0.17,1.98,0.08],
      cii = document.querySelector('.ctext'),
      dci = document.querySelector('.dctext'),
      cb = document.querySelector('.cipherB'),
      dcb = document.querySelector('.dcipherB');

  var kw = [],
      kwL,
      c = {og: '', min: '', ci: ''},
      dc = Object.create(c),
      ca = [],
      dca = [],
      rp = [],
      pt = [],
      indie = {},
      pos = 0,
      ccl = 0;

  function init(cd) {
    cd.og = (cd==c ? cii.value : dci.value);
    cd.min = cd.og.replace(/[^\w\s]|_/g," ").replace(/\s+/g," ").toLowerCase();
    cd==c ? ca = c.min.split('') : dca = dc.min.split('');
    cd==c ? ca = ca.filter(x => x!==' ') : dca = dca.filter(x => x!==' ');
    pos = 0;
  }

  function genKey() {
    kwL = Math.abs(Math.round(Math.random()*(5-ca.length/10)+5));
    for (let i = 0; i < kwL; i++) {
      let ranlet = Math.abs(Math.round(Math.random()*(0-25)));
      kw[i] = abc[ranlet];
    }
    cipher();
  }

  function cipher() {
    for (let i = pos; i < kwL+pos; i++) {
      let keyInd = abc.findIndex(x => x == kw[i%kwL]);
      let cInd = abc.findIndex(x => x == ca[i]);
      let newLet = (keyInd+cInd)%26;
      ca[i] = abc[newLet];
    }
    pos += kwL;
    while (pos<ca.length) {
      cipher();
    }
    c.ci = ca.join('');
  }

  cb.addEventListener('click', function() {
    if (ccl%2) {
      cb.textContent = 'get cipherd';
      cii.value = c.og;
    } else {
      init(c);
      genKey();
      cii.value = c.ci;
      cb.textContent = 'show og';
    }
    ccl++;
  });

  dcb.addEventListener('click', function() {
    init(dc);
    dci.value = dca.join('');
    patterns();
  });

  function patterns() {
    let r = 0;
    let dup = {};
    for (let i=r; i<dca.length; i++) {
      rp[i] = dca[i]+dca[i+1]+dca[i+2];
    }
    rp = rp.slice(0, -2);
    for (let i=0; i<rp.length; i++) {
      if(dup[rp[i]]) {
        pt.push(rp[i]);
      }
      dup[rp[i]] = true;
    }
    console.log(rp, pt);
    gaps();
  }

  function gaps() {
    for (let i=0; i<pt.length; i++) {
      let m = 0;
      indie[pt[i]] = [rp.findIndex(x => x==pt[i])];
      let end = false;
      while (!end) {
        //whyyy does while loop only end after another run thro when it shouldve finished? does it evaluate cond only when it needs 2 repeat? seems lame 2 do what im ab to post loop :/
        m++;
        let nxt = rp.slice(indie[pt[i]][m-1]+1, -1);
        indie[pt[i]][m] = nxt.findIndex(x => x==pt[i]);
        end = indie[pt[i]].includes(-1);
        indie[pt[i]][m] += indie[pt[i]][m-1]+1;
      }
      indie[pt[i]].splice(-1, 1);
    }
    // spitFacts();
  }

  // function spitFacts() {
  //   let poss = [];
  //   let space = [];
  //   for (let i=0; i<dca.length/10; i++) {
  //     //init all poss factors
  //     poss[i] = i;
  //   }
  //   for (let i=0; i<pt.length; i++) {
  //     space[i] =
  //     for (let g=0; g<indie[pt[i]].length; g++) {
  //
  //     }
  //   }
  // }




</script>
</html>
