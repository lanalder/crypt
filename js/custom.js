// let v = 'DAZFI SFSPA VQLSN PXYSZ WXALC DAFGQ UISMT PHZGA MKTTF TCCFXKFCRG GLPFE TZMMM ZOZDE ADWVZ WMWKV GQSOH QSVHP WFKLS LEASEPWHMJ EGKPU RVSXJ XVBWV POSDE TEQTX OBZIK WCXLW NUOVJ MJCLLOEOFA ZENVM JILOW ZEKAZ EJAQD ILSWW ESGUG KTZGQ ZVRMN WTQSEOTKTK PBSTA MQVER MJEGL JQRTL GFJYG SPTZP GTACM OECBX SESCIYGUFP KVILL TWDKS ZODFW FWEAA PQTFS TQIRG MPMEL RYELH QSVWBAWMOS DELHM UZGPG YEKZU KWTAM ZJMLS EVJQT GLAWV OVVXH KWQILIEUYS ZWXAH HUSZO GMUZQ CIMVZ UVWIF JJHPW VXFSE TZEDF';

// let v = 'TYWUR USHPO SLJNQ AYJLI FTMJY YZFPV EUZTS GAHTU WNSFW EEEVAMYFFD CZTMJ WSQEJ VWXTU QNANT MTIAW AOOJS HPPIN TYDDM VKQUFLGMLB XIXJU BQWXJ YQZJZ YMMZH DMFNQ VIAYE FLVZI ZQCSS AEEXVSFRDS DLBQT YDTFQ NIVKU ZPJFJ HUSLK LUBQV JULAB XYWCD IEOWHFTMXZ MMZHC AATFX YWGMF XYWZU QVPYF AIAFJ GEQCV KNATE MWGKXSMWNA NIUSH PFSRJ CEQEE VJXGG BLBQI MEYMR DSDHU UZXVV VGFXVJZXUI JLIRM RKZYY ASETY MYWWJ IYTMJ KFQQT ZFAQK IJFIP FSYAGQXZVK UZPHF ZCYOS LJNQE MVK';

// let v = 'VVQGY TVVVK ALURW FHQAC MMVLE HUCAT WFHHI PLXHV UWSCI GINCMUHNHQ RMSUI MHWZO DXTNA EKVVQ GYTVV QPHXI NWCAB ASYYM TKSZRCXWRP RFWYH XYGFI PSBWK QAMZY BXJQQ ABJEM TCHQS NAEKV VQGYTVVPCA QPBSL URQUC VMVPQ UTMML VHWDH NFIKJ CPXMY EIOCD TXBJWKQGAN';

// let v = 'QRBAI UWYOK ILBRZ XTUWL EGXSN VDXWR XMHXY FCGMW WWSME LSXUZMKMFS BNZIF YEIEG RFZRX WKUFA XQEDX DTTHY NTBRJ LHTAI KOCZXQHBND ZIGZG PXARJ EDYSJ NUMKI FLBTN HWISW NVLFM EGXAI AAWSLFMHXR SGRIG HEQTU MLGLV BRSIL AEZSG XCMHT OWHFM LWMRK HPRFBELWGF RUGPB HNBEM KBNVW HHUEA KILBN BMLHK XUGML YQKHP RFBELEJYNV WSIJB GAXGO TPMXR TXFKI WUALB RGWIE GHWHG AMEWW LTAELNUMRE UWTBL SDPRL YVRET LEEDF ROBEQ UXTHX ZYOZB XLKAC KSOHNVWXKS MAEPH IYQMM FSECH RFYPB BSQTX TPIWH GPXQD FWTAI KNNBXSIYKE TXTLV BTMQA LAGHG OTPMX RTXTH XSFYG WMVKH LOIVU ALMLDLTSYV WYNVW MQVXP XRVYA BLXDL XSMLW SUIOI IMELI SOYEB HPHNRWTVUI AKEYG WIETG WWBVM VDUMA EPAUA KXWHK MAUPA MUKHQ PWKCXEFXGW WSDDE OMLWL NKMWD FWTAM FAFEA MFZBN WIHYA LXRWK MAMIKGNGHJ UAZHM HGUAL YSULA ELYHJ BZMSI LAILH WWYIK EWAHN PMLBNNBVPJ XLBEF WRWGX KWIRH XWWGQ HRRXW IOMFY CZHZL VXNVI OYZCMYDDEY IPWXT MMSHS VHHXZ YEWNV OAOEL SMLSW KXXFX STRVI HZLEFJXDAS FIE';

// let v = 'LPROZ OOGRJ ZGFLV TUKMC WFDQM PZXIJ LVRWQ XEOSZ ZHTEK UYSCRPTFCZ UHXIJ LPPTD CPRBY OSMGY TLEVD UAQMF IFMZV LVYTO QDLHXLBPLL KYCQY ODRKS ACTEU XZEVO UAQMF OSDSU BKMBJ QEORF WFQCKHKSOD INGJZ SHGVV LMSZD WWHFJ AVQGF NUWMW AOIXT CSRYC YPPTPLFUCR AVQHR RVRES QCKHM LGARF YHXZP CSNWS NCRQV GHRLR ZEDHFJVUPC XZJQC ATISQ SCGXN BALWY MAQCY OSD'

// let v = 'FIIFL VZOZS VPDCA ZVFSL EMRUL BQISC XVQTS NDMFT IDGIZ ILZDMFFLVZ YMHCG DIGSL DSHEZ SIWMM XPNAN TIIRJ SFMWB XIDPS EWHAIXYWQM EXVVV DMRUK XASPF OQTUP JLNTQ WTJYQ OLFOF EOVVW WTURXDIGPT LLMFT INJYF OLKZU FXMVK CZISV AHDQQ VEVDM RTWIR MWYJIGPRFO CFUWK ZYFUQ VGZZU KYLNT MXKZY SDEMW MMXPX SJUZK NAXQQZVJSA ZICWN ERSIL BTUWJ HLUFI ZFNTQ GYMLO TARQJ MFLJL ISXMUWUZPA VXUUD MVKNT MXUGL GZFPL BQFVZ HFQTI TSNQE XVSGR DSDLBQBVVK YZOIF XNTQW LFZAX PFOCZ SHRJE ZQWJD CWQEU JYMYR FOUDQJIGFU ORFLU YAYJW MTMPC VCEFY ITNTU WYSFX AAUZI GEIZS GEQRKOCFTF IGIYN IWGLQ FSJOY QBXYW XGEXS WBUZH KZYPA SI'

let kwl = 0,
  ptkwl = [],
  table = [],
  v,
  of;

let omni = {
  abc: [],
  eng: [8.15, 1.44, 2.76, 3.79, 13.11, 2.92, 1.99, 5.26, 6.35, 0.13, 0.42, 3.39, 2.54, 7.10, 8.00, 1.98, 0.12, 6.83, 6.10, 10.47, 2.46, 0.92, 1.54, 0.17, 1.98, 0.08],
  // get overflow() {
  //   let decimal = (v.length / kwl) - Math.floor(v.length / kwl);
  //   return Math.floor(v.length * (decimal / 10));
  // },
  abcInit() {
    for (let i = 97; i < 123; i++) {
      this.abc[i - 97] = String.fromCharCode(i);
    }
  }
};

let patterns = {
  allF: [],
  factors: [[], []],
  shifts(setSize) {
    // chronologically 1.2, creates sets of length = setSize, returning each set of sets before shifting along 1 until setSize and returning that etc, since pattern repeats aren't gonna adhere to sets always sectioned from 0
    let a = [];
    let p = 0;
    for (let sh = 0; sh < setSize; sh++) {
      // 1st loop for shifting start of set (better data if not just sets of 3 from 0 taken but 3 from 1 etc), 2nd sets those sets in2 sets :O + p is inc to determine start, i is pos in sets
      for (let i = 0; i < v.length / setSize - 1; i++) {
        a.push(v.substring(i * setSize + p, i * setSize + setSize + p));
      }
      p++;
    }
    return a;
  },
  countRPs(set) {
    // chronologically 1.3, finds n counts repeats
    let occr = [];
    let no = new Map();

    set.forEach((x) => {
      let i = set.indexOf(x);
      // rp patterns go into occr as many times as they occur, Map so each pattern count can b counted / only set once (i feel like there was a way 2 do this w arrs?? but i read it n then forgot it??)o:
      if (set.indexOf(x, i + 1) !== -1) {
        occr.push(x);
        no.set(x, 0);
      }
    });

    occr.sort();
    // sort (default 2 alphabetically) so can just compare neighbours
    for (let i = 0; i < occr.length; i++) {

      if (occr[i] === occr[i + 1]) {
        let c = no.get(occr[i]);
        no.set(occr[i], c + 1);
      }
    }
    return no;
  },

  findRPs(setSize) {
    // chronologically, no.1; finds repeating patterns of lengths 3, 4, 5, 6 (length determined by setSize, which is determined by loop in keycutter)
    let sets = this.shifts(setSize);
    let gaps = [];

    Array.from(this.countRPs(sets).keys()).forEach((x) => {
      gaps.push(v.indexOf(x));
      // push ind of rp set, n from that ind of sets (last ele of gaps from above, -1) push next (+1) ind of same rp until no more tb found
      while (v.indexOf(x, gaps[gaps.length - 1] + 1) !== -1) {
        gaps.push(v.indexOf(x, gaps[gaps.length - 1] + 1));
      }
    });

    let m = Array.from(this.countRPs(sets).values());
    // finds not the indices of repeats but the dist between them
    for (let i = 0; i < gaps.length; i++) {

      for (let j = 0; j < m[i]; j++) {
        gaps[i + j] = gaps[i + j + 1] - gaps[i + j];
        gaps.splice(i + j + 1, 1);
      }
    }

    for (let i = 0; i < gaps.length; i++) {
      factor(gaps[i]);
    }

    // counts n stores factors that occur enough (more than once lol still keeping options open at this point) 2 b plausible
    this.allF = this.allF.flat();
    this.allF.forEach((x) => {
      let occr = this.allF.filter(y => y === x);

      if (!this.factors[0].includes(x) && occr.length > 1) {
        this.factors[0].push(x);
        this.factors[1].push(occr.length);
      }
    });
    this.allF = [];
  }
};

function factor(x) {
  // chronologically 1.4, having found rp patterns find common factors of dist between them
  let dv = 3;

  let few = [];

  while (dv < 20) {
    if (x % dv || dv === few[few.length - 1]) {
      dv += 1;
    } else {
      few.push(dv);
      if (few.length > 3) {
        dv = 20;
      }
    }
  }
  if (!few.length) {
    few = [x];
  }
  patterns.allF.push(few);
}

let freqkey = {
  ic: [[], []],
  chi: [],
  bigBoyIC: [0, 0, 0],

  calcIC() {
    // chronologically 2.1, for each coset count how many times each letter shows up, then do the formula thing, sum, push
    let form = set26();

    for (let i = 0; i < table.length; i++) {
      let occr = set26();
      for (let j = 0; j < table[i].length; j++) {
        occr[omni.abc.indexOf(table[i][j])] += 1;
      }
      occr.forEach((x, l) => {
        form[l] += (x / table[i].length) * ((x - 1) / (table[i].length - 1));
      });
    }

    let icsum = 0;
    form.forEach((x) => {
      icsum += x;
    });

    this.ic[0].push(kwl);
    this.ic[1].push(icsum / kwl);
  },

  icButPlain() {
    let occr = set26();
    let form = set26();

    for (let i = 0; i < v.length; i++) {
      occr[omni.abc.indexOf(v[i])] += 1;
    }
    occr.forEach((x, l) => {
      form[l] += (x / v.length) * ((x - 1) / (v.length - 1));
    });

    let icsum = 0;
    form.forEach((x) => {
      icsum += x;
    });

    return icsum;
  },

  chiron() {
    for (let i = 0; i < kwl; i++) {
      let chi = set26();

      chi = chi.map((x, l) => {
        let fs = [];

        let shifty = table[i].map((y) => {
          let og = omni.abc.indexOf(y);
          return omni.abc[Math.abs(26 + (og - l)) % 26];
        });

        shifty.forEach((a) => {
          let letpos = omni.abc.indexOf(a);
          let fe = omni.eng[letpos] / 100;
          let occr = shifty.filter(y => y === a);
          let dif = (occr.length / 10) - fe;
          let top = Math.pow(dif, 2);

          fs.push(top / fe);
          shifty = shifty.filter(y => y !== a);
        });

        let xsum = 0;
        fs.forEach((y) => {
          xsum += y;
        });

        return xsum;
      });

      chi.forEach((x) => {
        // someone needs 2 take for loops away from me but lit how else would one do this...
        let sml = chi.filter(y => y < x);
        sml.sort((a, b) => {
          return a - b;
        });

        this.chi[i] = chi.indexOf(sml[0]);
      });
    }
  }
};

function keycutter() {
  // v = v.replace(/[^\w\s]|_/g, " ").replace(/\s+/g, "").toLowerCase();
  // omni.abcInit();
  // 1. factors of kwl
  for (let i = 3; i < 7; i++) {
    patterns.findRPs(i);
  }
  // 2. set kwl 2 plausible options, ie. common factors (factors aren't enough to determine kwl as factors can b factors of each other yk); matrix having made table of kwl cosets begins finding incident coincident whatsit called the probability of 2 same letters being picked at random, which in coherent eng text is 0.06something whilst in gibbledegook more like 0.03 (if ciphertext on that assumed kwl has similar letter distribution / repeats to normal english (ie. bigger is better) then that kwl is probably the go)
  for (let i = 0; i < patterns.factors[0].length; i++) {
    kwl = patterns.factors[0][i];
    matrix();
    table = [];
  }
  // 2.1 find biggest IC n with it have kwl determined (hopefully)!
  freqkey.ic[1].forEach((x, i) => {
    if (x > freqkey.bigBoyIC[2] || patterns.factors[1][i] >= freqkey.bigBoyIC[1]) {
      freqkey.bigBoyIC = [freqkey.ic[0][i], patterns.factors[1][i], x];
      // factor, occr count, ic
    }
  });
  kwl = freqkey.bigBoyIC[0];
  matrix();
  freqkey.chiron();
  solve();
}

function matrix() {
  // unlikely that text will nicely divide into kwl
  let overflow = v.length % kwl;

  for (let i = 0; i < kwl; i++) {
    // table organised into rows of cosets
    table[i] = [];

    for (let j = 1; j < v.length / kwl; j++) {
      // sometimes the
      if (j) {
        table[i].push(v[j * kwl - (kwl - i)]);
      }
    }

    if (overflow) {
      table[i].push(v[v.length - overflow]);
      console.log(v[v.length - overflow]);
      overflow -= 1;
    }
  }

  if (!freqkey.bigBoyIC[0] && !ptkwl.length) {
    freqkey.calcIC();
  }
}

function solve() {
  let unciphd = new Array(v.length);

  for (let i = 0; i < kwl; i++) {

    // subbing in the de/ciphered letters
    table[i] = table[i].map((x, ind) => {
      let og = omni.abc.indexOf(x);

      // if there are vals in .chi, decipher rather than cipher; deciphering moves the alphabet left while cipher goes right
      return (freqkey.chi.length
        ? omni.abc[Math.abs(26 + (og - freqkey.chi[i])) % 26]
        : omni.abc[(og + ptkwl[i]) % 26]);
    });

    // table has rows of cosets, while new text needs to be ordered according to columns; second ind (ind of coset rows) of table is that many kwls away from 0, then + i for offset from start of kw
    table[i].forEach((x, ind) => {
      unciphd[kwl * ind + i] = x;
    });
  }

  document.querySelector('.inp').value = unciphd.join(' ');
}

function set26() {
  // ind = letter, for counting occurances etc.
  let arr = new Array(26);
  for (let i = 0; i < 26; i++) {
    arr[i] = 0;
  }
  return arr;
}

// dom + ciphering stuff

document.querySelector('.btn').addEventListener('click', function() {
  document.querySelector('.tellkw').textContent = '';
  omni.abcInit();

  if (document.querySelector('.inp').value !== "") {
    v = document.querySelector('.inp').value;

    v = v.replace(/[^\w\s]|_/g, " ").replace(/\s+/g, "").toLowerCase();
    if (v.length < 20) {
      // tell them is better when longer, option 2 proceed tho
    }
    if (freqkey.icButPlain() < 0.055) {
      keycutter();
      revealKW();
    } else {
      ciphed();
    }
  }
  reset();
}, false);

function ciphed() {
  let max = Math.ceil(v.length / 25);
  if (max < 3) {
    max = 5;
  } else if (max > 18) {
    max = 12;
  }
  for (let i = 0; i < Math.round(Math.random() * (max - 3) + 3); i++) {
    ptkwl[i] = Math.round(Math.random() * 25);
  }

  kwl = ptkwl.length;
  matrix();
  solve();
  revealKW();
}

function revealKW() {
  let rkw = '';
  if (ptkwl.length) {
    ptkwl.forEach((x) => {
      rkw += `${omni.abc[x]}`;
      // is temp lit necessary?
    });
  } else {
    // bug here: kw shouldn't rp
    freqkey.chi.forEach((x) => {
      rkw += `${omni.abc[x]}`;
    });
  }
  document.querySelector('.tellkw').textContent = rkw;
}

function reset() {
  kwl = 0;
  ptkwl = [];
  table = [];
  v = null;
  patterns.allF = [];
  patterns.factors = [[], []];
  freqkey.ic = [[], []];
  freqkey.chi = [];
  freqkey.bigBoyIC = [0, 0, 0];
}
